"use strict";(globalThis.webpackChunk_8x8_developer_docs=globalThis.webpackChunk_8x8_developer_docs||[]).push([[92496],{4865:(e,n,t)=>{t.d(n,{A:()=>g});var i=t(96540),s=t(34164),r=t(17559),a=t(23104),l=t(47751),c=t(92303);const o={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var d=t(74848);function u({className:e,block:n,selectedValue:t,selectValue:i,tabValues:r}){const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,a.a_)(),u=e=>{const n=e.currentTarget,s=l.indexOf(n),a=r[s].value;a!==t&&(c(n),i(a))},h=e=>{let n=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const t=l.indexOf(e.currentTarget)+1;n=l[t]??l[0];break}case"ArrowLeft":{const t=l.indexOf(e.currentTarget)-1;n=l[t]??l[l.length-1];break}}n?.focus()};return(0,d.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":n},e),children:r.map(({value:e,label:n,attributes:i})=>(0,d.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{l.push(e)},onKeyDown:h,onClick:u,...i,className:(0,s.A)("tabs__item",o.tabItem,i?.className,{"tabs__item--active":t===e}),children:n??e},e))})}function h({lazy:e,children:n,selectedValue:t}){const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=r.find(e=>e.props.value===t);return e?(0,i.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,d.jsx)("div",{className:"margin-top--md",children:r.map((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==t}))})}function v(e){const n=(0,l.u)(e);return(0,d.jsxs)("div",{className:(0,s.A)(r.G.tabs.container,"tabs-container",o.tabList),children:[(0,d.jsx)(u,{...n,...e}),(0,d.jsx)(h,{...n,...e})]})}function g(e){const n=(0,c.default)();return(0,d.jsx)(v,{...e,children:(0,l.v)(e.children)},String(n))}},19365:(e,n,t)=>{t.r(n),t.d(n,{default:()=>a});t(96540);var i=t(34164);const s={tabItem:"tabItem_Ymn6"};var r=t(74848);function a({children:e,hidden:n,className:t}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,i.A)(s.tabItem,t),hidden:n,children:e})}},24774:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>v,frontMatter:()=>c,metadata:()=>i,toc:()=>u});const i=JSON.parse('{"id":"actions-events/docs/streaming/event-lifecycle","title":"Event Lifecycle","description":"Understanding how events flow through an interaction\'s lifecycle helps you build robust integrations and accurately track interaction progress.","source":"@site/docs/actions-events/docs/streaming/event-lifecycle.mdx","sourceDirName":"actions-events/docs/streaming","slug":"/actions-events/docs/streaming/event-lifecycle","permalink":"/actions-events/docs/streaming/event-lifecycle","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"sidebarActionsEventsDocs","previous":{"title":"Message Format","permalink":"/actions-events/docs/streaming/message-format"},"next":{"title":"Event Reference","permalink":"/actions-events/docs/streaming/event-reference"}}');var s=t(74848),r=t(28453),a=t(4865),l=t(19365);const c={sidebar_position:6},o="Event Lifecycle",d={},u=[{value:"Overview",id:"overview",level:2},{value:"Inbound Call Lifecycle",id:"inbound-call-lifecycle",level:2},{value:"Outbound Call Lifecycle",id:"outbound-call-lifecycle",level:2},{value:"Rejected/Abandoned Call Flow",id:"rejectedabandoned-call-flow",level:2},{value:"Agent Rejects Interaction",id:"agent-rejects-interaction",level:3},{value:"Customer Abandons Queue",id:"customer-abandons-queue",level:3},{value:"Outbound Call Not Answered",id:"outbound-call-not-answered",level:3},{value:"Agent State Events",id:"agent-state-events",level:2},{value:"Tracking Complete Interactions",id:"tracking-complete-interactions",level:2},{value:"Example: Building an Interaction Timeline",id:"example-building-an-interaction-timeline",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Event Correlation",id:"event-correlation",level:3},{value:"State Management",id:"state-management",level:3},{value:"Metric Calculation",id:"metric-calculation",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Next Steps",id:"next-steps",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"event-lifecycle",children:"Event Lifecycle"})}),"\n",(0,s.jsx)(n.p,{children:"Understanding how events flow through an interaction's lifecycle helps you build robust integrations and accurately track interaction progress."}),"\n","\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Contact center interactions (calls, chats, emails) progress through a series of states, with each state transition generating an event. By tracking these events and their sequence, you can:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Build real-time dashboards showing interaction status"}),"\n",(0,s.jsx)(n.li,{children:"Calculate key metrics (queue time, talk time, wrap-up duration)"}),"\n",(0,s.jsx)(n.li,{children:"Correlate events to understand complete customer journeys"}),"\n",(0,s.jsx)(n.li,{children:"Identify patterns and optimize routing rules"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"inbound-call-lifecycle",children:"Inbound Call Lifecycle"}),"\n",(0,s.jsx)(n.p,{children:"A typical inbound phone call generates events in this sequence:"}),"\n",(0,s.jsx)(n.mermaid,{value:"flowchart TD\n    A[InteractionCreated<br/>CS_IDLE] --\x3e B[InteractionQueued<br/>CS_QUEUED]\n    B --\x3e C[InteractionAssigned<br/>CS_INPROGRESS<br/>Offered to agent]\n    C --\x3e D[InteractionAccepted<br/>CS_CONNECTED<br/>Agent accepts]\n    D --\x3e E{Hold?}\n    E --\x3e|Optional| F[LineHoldStatus<br/>CS_HOLD<br/>Agent places on hold]\n    F --\x3e G[LineHoldStatus<br/>CS_CONNECTED<br/>Agent takes off hold]\n    G --\x3e H[InteractionPostProcess<br/>CS_DISCONNECTED<br/>Call ends, wrap-up begins]\n    E --\x3e|No hold| H\n    H --\x3e I[InteractionEndPostProcess<br/>CS_DISCONNECTED<br/>Wrap-up ends]\n    I --\x3e J[InteractionDeassigned<br/>CS_DISCONNECTED<br/>Agent released]\n    J --\x3e K[InteractionDeleted<br/>CS_DISCONNECTED<br/>Final event]"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Fields to Track:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"interactionGUID"}),": Unique identifier to correlate all events for this interaction"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"callState"}),": Current state in the lifecycle"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"eventTS"})," or ",(0,s.jsx)(n.code,{children:"interactionEventTS"}),": When each transition occurred"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"agentId"}),": Which agent handled the interaction (from InteractionAssigned onward)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"outbound-call-lifecycle",children:"Outbound Call Lifecycle"}),"\n",(0,s.jsx)(n.p,{children:"Outbound calls (agent-initiated or campaign) have a slightly different flow:"}),"\n",(0,s.jsx)(n.mermaid,{value:"flowchart TD\n    A[InteractionCreated<br/>CS_IDLE] --\x3e B[InteractionAssigned<br/>CS_INPROGRESS<br/>Assigned to agent]\n    B --\x3e C[Outbound dialing occurs]\n    C --\x3e D[InteractionCustomerAccepted<br/>CS_CONNECTED<br/>Customer answers]\n    D --\x3e E{Hold?}\n    E --\x3e|Optional| F[LineHoldStatus<br/>CS_HOLD / CS_CONNECTED]\n    F --\x3e G[InteractionPostProcess<br/>CS_DISCONNECTED]\n    E --\x3e|No hold| G\n    G --\x3e H[InteractionEndPostProcess<br/>CS_DISCONNECTED]\n    H --\x3e I[InteractionDeassigned<br/>CS_DISCONNECTED]\n    I --\x3e J[InteractionDeleted<br/>CS_DISCONNECTED]"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key Difference:"})," Outbound calls skip the ",(0,s.jsx)(n.code,{children:"InteractionQueued"})," state and use ",(0,s.jsx)(n.code,{children:"InteractionCustomerAccepted"})," when the customer answers."]}),"\n",(0,s.jsx)(n.h2,{id:"rejectedabandoned-call-flow",children:"Rejected/Abandoned Call Flow"}),"\n",(0,s.jsx)(n.p,{children:"Not all interactions complete successfully. Here are common alternate flows:"}),"\n",(0,s.jsx)(n.h3,{id:"agent-rejects-interaction",children:"Agent Rejects Interaction"}),"\n",(0,s.jsx)(n.mermaid,{value:"flowchart LR\n    A[InteractionCreated<br/>CS_IDLE] --\x3e B[InteractionQueued<br/>CS_QUEUED]\n    B --\x3e C[InteractionAssigned<br/>CS_INPROGRESS]\n    C --\x3e D[InteractionRejected<br/>CS_QUEUED<br/>Agent rejects]\n    D --\x3e E[Returns to queue<br/>May be offered to<br/>another agent]"}),"\n",(0,s.jsx)(n.p,{children:"When an agent rejects an offered interaction, it returns to the queue and may be offered to another agent."}),"\n",(0,s.jsx)(n.h3,{id:"customer-abandons-queue",children:"Customer Abandons Queue"}),"\n",(0,s.jsx)(n.mermaid,{value:"flowchart LR\n    A[InteractionCreated<br/>CS_IDLE] --\x3e B[InteractionQueued<br/>CS_QUEUED]\n    B --\x3e C[InteractionUnqueued<br/>CS_IDLE or CS_DISCONNECTED<br/>Customer hangs up]\n    C --\x3e D[InteractionDeleted<br/>CS_DISCONNECTED]"}),"\n",(0,s.jsxs)(n.p,{children:["If a customer hangs up while waiting in queue, you'll see ",(0,s.jsx)(n.code,{children:"InteractionUnqueued"})," followed by ",(0,s.jsx)(n.code,{children:"InteractionDeleted"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"outbound-call-not-answered",children:"Outbound Call Not Answered"}),"\n",(0,s.jsx)(n.mermaid,{value:"flowchart LR\n    A[InteractionCreated<br/>CS_IDLE] --\x3e B[InteractionAssigned<br/>CS_INPROGRESS]\n    B --\x3e C[No answer, busy, or failed]\n    C --\x3e D[InteractionDeleted<br/>CS_DISCONNECTED<br/>hangupInitiator: SYSTEM<br/>callHangupReason: CEC_DISCONNECT_NOANSWER]"}),"\n",(0,s.jsxs)(n.p,{children:["When an outbound call doesn't connect, the ",(0,s.jsx)(n.code,{children:"InteractionDeleted"})," event includes diagnostic information about why the call failed."]}),"\n",(0,s.jsx)(n.h2,{id:"agent-state-events",children:"Agent State Events"}),"\n",(0,s.jsx)(n.p,{children:"In parallel with interaction events, agent state changes are tracked separately:"}),"\n",(0,s.jsx)(n.mermaid,{value:"flowchart TD\n    A[Agent logs in<br/>AgentStatusChange<br/>newState: 1 = LOGGED_IN] --\x3e B[Agent goes available<br/>AgentStatusChange<br/>newState: 5 = AVAILABLE]\n    B --\x3e C{Skills/provisioning<br/>changes?}\n    C --\x3e|Yes| D[AgentProvChange or<br/>AgentSkillChanged]\n    D --\x3e E[Agent handles interactions...]\n    C --\x3e|No| E\n    E --\x3e F[Agent goes unavailable<br/>AgentStatusChange<br/>newState: different state]\n    F --\x3e G[Agent logs out<br/>AgentStatusChange<br/>newState: 0 = LOGGED_OUT]"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," Agent events are published to:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tenant/event-v1/all"})," (all events topic)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tenant/event-v1/AgentStatusChange"})," (event-specific topic)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tenant/agent-v1/{agentId}"})," (agent-specific topic)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"tracking-complete-interactions",children:"Tracking Complete Interactions"}),"\n",(0,s.jsx)(n.p,{children:"To track a complete interaction from start to finish:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Use ",(0,s.jsx)(n.code,{children:"interactionGUID"})]})," as the correlation key across all events"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Track state transitions"})," via ",(0,s.jsx)(n.code,{children:"callState"})," field"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitor timestamps"})," using ",(0,s.jsx)(n.code,{children:"eventTS"})," or ",(0,s.jsx)(n.code,{children:"interactionEventTS"})," to calculate durations:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Queue time"}),": InteractionQueued.eventTS \u2192 InteractionAssigned.eventTS"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Ring time"}),": InteractionAssigned.eventTS \u2192 InteractionAccepted.eventTS"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Talk time"}),": InteractionAccepted.eventTS \u2192 InteractionPostProcess.eventTS"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Wrap-up time"}),": InteractionPostProcess.eventTS \u2192 InteractionEndPostProcess.eventTS"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Capture outcome"})," from InteractionDeleted:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"hangupInitiator"}),": Who ended the call"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"callHangupReason"}),": Why the call ended"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"dispositionCode"}),": Agent's wrap-up disposition"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"example-building-an-interaction-timeline",children:"Example: Building an Interaction Timeline"}),"\n",(0,s.jsx)(n.p,{children:"Here's a practical example of tracking interaction metrics by correlating events:"}),"\n",(0,s.jsxs)(a.A,{children:[(0,s.jsx)(l.default,{value:"go",label:"Go",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'type InteractionTimeline struct {\n    InteractionGUID string\n    Created         time.Time\n    Queued          time.Time\n    Assigned        time.Time\n    Connected       time.Time\n    Disconnected    time.Time\n    AgentID         string\n    QueueID         int\n    HangupReason    string\n}\n\nfunc (t *InteractionTimeline) ProcessEvent(event Event) {\n    switch event.Event {\n    case "InteractionCreated":\n        t.InteractionGUID = event.InteractionGUID\n        t.Created = time.Unix(event.EventTS, 0)\n    case "InteractionQueued":\n        t.Queued = time.Unix(event.EventTS, 0)\n        t.QueueID = event.QueueID\n    case "InteractionAssigned":\n        t.Assigned = time.Unix(event.EventTS, 0)\n        t.AgentID = event.AgentID\n    case "InteractionAccepted", "InteractionCustomerAccepted":\n        t.Connected = time.Unix(event.EventTS, 0)\n    case "InteractionDeleted":\n        t.Disconnected = time.Unix(event.EventTS, 0)\n        t.HangupReason = event.CallHangupReason\n    }\n}\n\nfunc (t *InteractionTimeline) QueueDuration() time.Duration {\n    if t.Queued.IsZero() || t.Assigned.IsZero() {\n        return 0\n    }\n    return t.Assigned.Sub(t.Queued)\n}\n\nfunc (t *InteractionTimeline) TalkDuration() time.Duration {\n    if t.Connected.IsZero() || t.Disconnected.IsZero() {\n        return 0\n    }\n    return t.Disconnected.Sub(t.Connected)\n}\n'})})}),(0,s.jsx)(l.default,{value:"python",label:"Python",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from datetime import datetime\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n@dataclass\nclass InteractionTimeline:\n    interaction_guid: Optional[str] = None\n    created: Optional[datetime] = None\n    queued: Optional[datetime] = None\n    assigned: Optional[datetime] = None\n    connected: Optional[datetime] = None\n    disconnected: Optional[datetime] = None\n    agent_id: Optional[str] = None\n    queue_id: Optional[int] = None\n    hangup_reason: Optional[str] = None\n\n    def process_event(self, event: dict):\n        event_type = event.get('event')\n\n        if event_type == 'InteractionCreated':\n            self.interaction_guid = event['interactionGUID']\n            self.created = datetime.fromtimestamp(event['eventTS'])\n        elif event_type == 'InteractionQueued':\n            self.queued = datetime.fromtimestamp(event['eventTS'])\n            self.queue_id = event.get('queueId')\n        elif event_type == 'InteractionAssigned':\n            self.assigned = datetime.fromtimestamp(event['eventTS'])\n            self.agent_id = event.get('agentId')\n        elif event_type in ['InteractionAccepted', 'InteractionCustomerAccepted']:\n            self.connected = datetime.fromtimestamp(event['eventTS'])\n        elif event_type == 'InteractionDeleted':\n            self.disconnected = datetime.fromtimestamp(event['eventTS'])\n            self.hangup_reason = event.get('callHangupReason')\n\n    def queue_duration(self) -> Optional[float]:\n        if self.queued and self.assigned:\n            return (self.assigned - self.queued).total_seconds()\n        return None\n\n    def talk_duration(self) -> Optional[float]:\n        if self.connected and self.disconnected:\n            return (self.disconnected - self.connected).total_seconds()\n        return None\n"})})}),(0,s.jsx)(l.default,{value:"nodejs",label:"Node.js",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class InteractionTimeline {\n    constructor() {\n        this.interactionGUID = null;\n        this.created = null;\n        this.queued = null;\n        this.assigned = null;\n        this.connected = null;\n        this.disconnected = null;\n        this.agentId = null;\n        this.queueId = null;\n        this.hangupReason = null;\n    }\n\n    processEvent(event) {\n        switch (event.event) {\n            case 'InteractionCreated':\n                this.interactionGUID = event.interactionGUID;\n                this.created = new Date(event.eventTS * 1000);\n                break;\n            case 'InteractionQueued':\n                this.queued = new Date(event.eventTS * 1000);\n                this.queueId = event.queueId;\n                break;\n            case 'InteractionAssigned':\n                this.assigned = new Date(event.eventTS * 1000);\n                this.agentId = event.agentId;\n                break;\n            case 'InteractionAccepted':\n            case 'InteractionCustomerAccepted':\n                this.connected = new Date(event.eventTS * 1000);\n                break;\n            case 'InteractionDeleted':\n                this.disconnected = new Date(event.eventTS * 1000);\n                this.hangupReason = event.callHangupReason;\n                break;\n        }\n    }\n\n    queueDuration() {\n        if (this.queued && this.assigned) {\n            return (this.assigned - this.queued) / 1000; // seconds\n        }\n        return null;\n    }\n\n    talkDuration() {\n        if (this.connected && this.disconnected) {\n            return (this.disconnected - this.connected) / 1000; // seconds\n        }\n        return null;\n    }\n}\n"})})})]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"event-correlation",children:"Event Correlation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Always use ",(0,s.jsx)(n.code,{children:"interactionGUID"})]})," to correlate events - it's the only reliable way to track an interaction across its entire lifecycle"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Store events"})," rather than just metrics - you may need to recalculate or debug later"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handle out-of-order events"})," - network delays can cause events to arrive out of sequence"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"state-management",children:"State Management"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Track ",(0,s.jsx)(n.code,{children:"callState"})," transitions"]})," to ensure your application state matches the interaction state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Expect optional events"})," - not all interactions follow the complete path (e.g., abandoned calls skip most steps)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handle missing events"})," - network issues or system restarts may cause missed events"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"metric-calculation",children:"Metric Calculation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use event timestamps"})," (",(0,s.jsx)(n.code,{children:"eventTS"})," or ",(0,s.jsx)(n.code,{children:"interactionEventTS"}),") for accurate duration calculations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Account for holds"})," - ",(0,s.jsx)(n.code,{children:"LineHoldStatus"})," events affect talk time calculations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consider time zones"})," - timestamps are in UTC, convert as needed for reporting"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Check ",(0,s.jsx)(n.code,{children:"hangupInitiator"})]})," and ",(0,s.jsx)(n.code,{children:"callHangupReason"})," in InteractionDeleted events to understand why interactions ended"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitor for anomalies"})," - unexpected state transitions may indicate system issues"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Log unhandled event types"})," - new event types may be added in future releases"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/actions-events/docs/streaming/message-format",children:"Message Format"})," - Detailed field descriptions and message structure"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/actions-events/docs/streaming/event-reference",children:"Event Reference"})," - Complete list of event types and their fields"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/actions-events/docs/streaming/field-reference",children:"Field Reference"})," - Detailed documentation for all event fields"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/actions-events/docs/streaming/examples/golang",children:"Code Examples"})," - Complete working implementations"]}),"\n"]})]})}function v(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(96540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}},47751:(e,n,t)=>{t.d(n,{u:()=>v,v:()=>o});var i=t(96540),s=t(56347),r=t(205),a=t(57485),l=t(89466),c=t(31682);function o(e){return i.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function d(e){const{values:n,children:t}=e;return(0,i.useMemo)(()=>{const e=n??function(e){return o(e).map(({props:{value:e,label:n,attributes:t,default:i}})=>({value:e,label:n,attributes:t,default:i}))}(t);return function(e){const n=(0,c.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,t])}function u({value:e,tabValues:n}){return n.some(n=>n.value===e)}function h({queryString:e=!1,groupId:n}){const t=(0,s.W6)(),r=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,a.aZ)(r),(0,i.useCallback)(e=>{if(!r)return;const n=new URLSearchParams(t.location.search);n.set(r,e),t.replace({...t.location,search:n.toString()})},[r,t])]}function v(e){const{defaultValue:n,queryString:t=!1,groupId:s}=e,a=d(e),[c,o]=(0,i.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!u({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find(e=>e.default)??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:a})),[v,g]=h({queryString:t,groupId:s}),[m,p]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,s]=(0,l.Dv)(n);return[t,(0,i.useCallback)(e=>{n&&s.set(e)},[n,s])]}({groupId:s}),x=(()=>{const e=v??m;return u({value:e,tabValues:a})?e:null})();(0,r.A)(()=>{x&&o(x)},[x]);return{selectedValue:c,selectValue:(0,i.useCallback)(e=>{if(!u({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);o(e),g(e),p(e)},[g,p,a]),tabValues:a}}}}]);